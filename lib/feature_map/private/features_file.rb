# typed: strict
# frozen_string_literal: true

module FeatureMap
  module Private
    #
    # This class is responsible for turning FeatureMap directives (e.g. annotations, directory assignments, etc)
    # into a FEAUTERS.yml file, that can be used as an input to a variety of engineering team utilities (e.g.
    # PR/release announcements, documentation generation, etc).
    #
    class FeaturesFile
      extend T::Sig

      sig { returns(T::Array[String]) }
      def self.actual_contents_lines
        if path.exist?
          content = path.read
          lines = path.read.split("\n")
          if content.end_with?("\n")
            lines << ''
          end
          lines
        else
          ['']
        end
      end

      sig { returns(T::Array[T.nilable(String)]) }
      def self.expected_contents_lines
        cache = Private.glob_cache.raw_cache_contents

        header = <<~HEADER
          # STOP! - DO NOT EDIT THIS FILE MANUALLY
          # This file was automatically generated by "bin/featuremap validate". The next time this file
          # is generated any changes will be lost. For more details:
          # https://github.com/Beyond-Finance/feature_map
        HEADER

        files_assignment_lines = T.let(['files:'], T::Array[String])
        feature_lines = T.let(['features:'], T::Array[String])

        feature_files_map = {}

        cache.each do |mapper_description, assignment_map_cache|
          files_assignment_entries = []
          assignment_map_cache = assignment_map_cache.sort_by do |glob, _feature|
            glob
          end
          assignment_map_cache.to_h.each do |path, feature|
            feature_files_map[feature.name] ||= []
            files_assignment_entries << "  #{path}: #{feature.name}"
            feature_files_map[feature.name] << path
          end

          next if files_assignment_entries.none?

          files_assignment_lines += ['', "# #{mapper_description}", *files_assignment_entries.sort]
        end

        feature_files_map.each do |feature_name, files|
          # TODO: The complexity score for the feature needs to be calculated and recorded.
          feature_lines += ['', "  #{feature_name}:", '    files:', *files.sort.map { |path| "      - #{path}" }]
        end

        [
          *header.split("\n"),
          '', # For line between header and files_assignment_lines
          *files_assignment_lines,
          '', # For line between files_assignment_lines and feature_lines
          *feature_lines,
          '' # For end-of-file newline
        ]
      end

      sig { void }
      def self.write!
        FileUtils.mkdir_p(path.dirname) if !path.dirname.exist?
        path.write(expected_contents_lines.join("\n"))
      end

      sig { returns(Pathname) }
      def self.path
        Pathname.pwd.join('FEATURES.yml')
      end

      sig { params(files: T::Array[String]).void }
      def self.update_cache!(files)
        cache = Private.glob_cache
        # Each mapper returns a new copy of the cache subset related to that mapper,
        # which is then stored back into the cache.
        Mapper.all.each do |mapper|
          existing_cache = cache.raw_cache_contents.fetch(mapper.description, {})
          updated_cache = mapper.update_cache(existing_cache, files)
          cache.raw_cache_contents[mapper.description] = updated_cache
        end
      end

      sig { returns(T::Boolean) }
      def self.use_features_cache?
        FeaturesFile.path.exist? && !Private.configuration.skip_features_validation
      end

      sig { returns(GlobCache) }
      def self.to_glob_cache
        # TODO: This method needs to be implemented.
        GlobCache.new({})
      end
    end
  end
end
