# typed: strict
# frozen_string_literal: true

module FeatureMap
  module Private
    #
    # This class is responsible for compiling a set of feature-level test pyramid statistics into a test-pyramid.yml
    # This file can then be used as an input to a variety of engineering team utilities
    # (e.g. PR/release announcements, documentation generation, etc).
    #
    class TestPyramidFile
      extend T::Sig

      class FileContentError < StandardError; end

      FEATURES_KEY = 'features'

      FeatureName = T.type_alias { String }
      PyramidStat = T.type_alias { String }

      FeaturePyramid = T.type_alias do
        T::Hash[
          PyramidStat,
          Integer
        ]
      end

      FeaturesContent = T.type_alias do
        T::Hash[
          FeatureName,
          FeaturePyramid
        ]
      end

      sig do
        params(
          unit_examples: T::Array[T::Hash[T.untyped, T.untyped]],
          integration_examples: T::Array[T::Hash[T.untyped, T.untyped]],
          regression_examples: T::Array[T::Hash[T.untyped, T.untyped]],
          regression_assignments: T::Hash[T.untyped, T.untyped]
        ).void
      end
      def self.write!(unit_examples, integration_examples, regression_examples, regression_assignments)
        FileUtils.mkdir_p(path.dirname) if !path.dirname.exist?

        regression_file_assignments = regression_assignments['features']&.transform_values do |feature|
          feature['files']&.map { |file| filepath(file) } || []
        end || {}

        content = generate_content(
          unit_examples.group_by { |ex| filepath(ex['id']) },
          integration_examples.group_by { |ex| filepath(ex['id']) },
          regression_examples.group_by { |ex| filepath(ex['id']) },
          regression_file_assignments
        )
        path.write([header_comment, "\n", { FEATURES_KEY => content }.to_yaml].join)
      end

      sig { returns(Pathname) }
      def self.path
        Pathname.pwd.join('.feature_map/test-pyramid.yml')
      end

      sig { returns(String) }
      def self.header_comment
        <<~HEADER
          # STOP! - DO NOT EDIT THIS FILE MANUALLY
          # This file was automatically generated by "bin/featuremap test_pyramid". The next time this file
          # is generated any changes will be lost. For more details:
          # https://github.com/Beyond-Finance/feature_map
          #
          # It is NOT recommended to commit this file into your source control. It will change or become
          # outdated frequently. Instead it should be regenerated when test pyramid statistics are required.
          # This file should be ignored by your source control, allowing the local copy to be used for other
          # feature analysis operations (e.g. documentation generation, etc).
        HEADER
      end

      sig do
        params(
          unit_examples: T::Hash[T.untyped, T.untyped],
          integration_examples: T::Hash[T.untyped, T.untyped],
          regression_examples: T::Hash[T.untyped, T.untyped],
          regression_file_assignments: T::Hash[T.untyped, T.untyped]
        ).returns(FeaturesContent)
      end
      def self.generate_content(unit_examples, integration_examples, regression_examples, regression_file_assignments)
        Private.feature_file_assignments.reduce({}) do |content, (feature_name, files)|
          regression_files = regression_file_assignments[feature_name] || []
          regression_count, regression_pending = regression_files.reduce([0, 0]) do |accumulated_counts, file|
            accumulated_count, accumulated_pending = accumulated_counts
            count, pending = split(regression_examples[file])

            [accumulated_count + count, accumulated_pending + pending]
          end

          pyramid = files.reduce({}) do |acc, file|
            normalized_path = filepath(file)

            unit_count, unit_pending = split(unit_examples["#{normalized_path}_spec"])
            integration_count, integration_pending = split(integration_examples[normalized_path])

            {
              'unit_count' => (acc['unit_count'] || 0) + unit_count,
              'unit_pending' => (acc['unit_pending'] || 0) + unit_pending,
              'integration_count' => (acc['integration_count'] || 0) + integration_count,
              'integration_pending' => (acc['integration_pending'] || 0) + integration_pending
            }
          end

          {
            feature_name => pyramid.merge(
              'regression_count' => regression_count,
              'regression_pending' => regression_pending
            ),
            **content
          }
        end
      end

      sig { returns(FeaturesContent) }
      def self.load_features!
        test_coverage_content = YAML.load_file(path)

        return test_coverage_content[FEATURES_KEY] if test_coverage_content.is_a?(Hash) && test_coverage_content[FEATURES_KEY]

        raise FileContentError, "Unexpected content found in #{path}. Use `bin/featuremap test_coverage` to regenerate it and try again."
      rescue Psych::SyntaxError => e
        raise FileContentError, "Invalid YAML content found at #{path}. Error: #{e.message} Use `bin/featuremap test_coverage` to generate it and try again."
      rescue Errno::ENOENT
        raise FileContentError, "No feature test coverage file found at #{path}. Use `bin/featuremap test_coverage` to generate it and try again."
      end

      sig { params(examples: T.nilable(T::Array[T::Hash[T.untyped, T.untyped]])).returns(T::Array[Integer]) }
      def self.split(examples)
        return [0, 0] if examples.nil?

        examples.partition { |ex| ex['status'] == 'passed' }.map(&:count)
      end

      sig { params(pathlike: String).returns(String) }
      def self.filepath(pathlike)
        File
          .join(File.dirname(pathlike), File.basename(pathlike, '.*'))
          .gsub(%r{^\./}, '')
          .gsub(%r{^spec/}, '')
          .gsub(%r{^app/}, '')
      end
    end
  end
end
